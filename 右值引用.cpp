//
// Created by Administrator on 2023/7/27.
//
/*
 * 左值、右值
 * 在C++中，所有的值不是左值，就是右值。左值是指表达式结束之后依然存在的持久好化对象，右值是指表达式结束之后就不再存在的临时对象
 * 有名字的对象都是左值，右值没有名字
 * 如果返回的是引用，那么就不是右值了，是左值
 * 还有一个区别左值右值的方法：看能不能对表达式取地址，如果能则为左值，反之则为右值
 * C++11扩展了右值的概念，将右值分为了纯右值和将亡值
 *
 * 纯右值 a 非引用返回的临时变量
 *       b 运算表达式产生的结果
 *       c 字面常量（C风格字符串除外，它是地址）
 * 将亡值:与右值引用相关的表达式，例如：将要被移动的对象、T&&函数返回的值、std::move()的返回值、转换成T&&类型的转换函数的返回值
 * 可以将纯右值和将亡值统一看作右值，不影响使用
 *
 * 左值引用、右值引用
 * C++98中的引用很常见，就是给变量取个别名，在C++11中，因为增加了右值引用的概念，所以C++98中的引用都称为了左值引用
 * 右值引用就是给右值取个别名，使用的符号是&&
 * 语法 数据类型&&变量名=右值
 *
 * 引入右值引用的主要目的是移动语义
 * 左值引用只能绑定左值，右值引用只能绑定右值，如果绑定的不对，编译就会失败
 * 但是，常量左值引用可以算是一个万能的引用类型，它可以绑定非常量左值、常量左值、右值，而且在绑定右值的时候，常量左值引用还可以像右值引用一样将
 * 右值的生命期延长，缺点是只能读不能改
 */
#include "iostream"

using namespace std;

class A {
public:
    int m_a = 9;
};

A getTemp() {
    return A();
}

void test01() {
    int &&a = 3;
    a++;
    int b = 8;
    int &&c = b + 5;
    c++;
    A &&aa = getTemp(); //getTemp()的返回值是临时对象，右值
    //getTemp()的返回值本来在表达式语句结束后其生命也就该终结了(因为是临时变量)，而通过右值引用重获新生
    //其生命周期将于右值引用类型变量aa的生命周期一样，只要aa还活着，该右值临时变量将会一直存活下去

    cout << "a=" << &a << endl;
    cout << "c=" << &c << endl;
    cout << "aa.m_a=" << &aa.m_a << endl;
}

void test02() {
    int a=1;
    const int&ra=a; //a是非常量左值

    const int b=1;
    const int&rb=b; //b是常量左值
    const int&rc=1; //1是右值
}

int main() {
    //test01();
    test02();
}